package com.layerglue.components{	import fl.controls.Button;	import fl.core.InvalidationType;	import fl.core.UIComponent;	import fl.events.ComponentEvent;		import flash.text.AntiAliasType;	import flash.text.TextFieldAutoSize;		/**	 * LGButton adds additional functionality to the standard CS4 Button component. It can be used	 * in exactly the same way as the original component, but supports extras features such as 	 * anti-alias support and auto-sizing of based on label length.	 */	public class LGButton extends Button implements ILGComponent	{		private static var defaultStyles:Object = { antiAliasType: null }		public function LGButton()		{			super();		}				protected var _autoSize:Boolean = false;		/**		 * Sets the automatic sizing of the button based on the label length. If true the button		 * width will match the label width, if false the label will be truncated if it's		 * wider than the button. Defaults to false.		 */		public function get autoSize():Boolean		{			return _autoSize;		}				public function set autoSize(value:Boolean):void		{			_autoSize = value;			if (value == true)			{				textField.autoSize = TextFieldAutoSize.LEFT;			}			else			{				textField.autoSize = TextFieldAutoSize.NONE;			}			invalidate(InvalidationType.SIZE);		}				public static function getStyleDefinition():Object		{ 			return UIComponent.mergeStyles(Button.getStyleDefinition(), defaultStyles);		}				override protected function drawTextFormat():void		{			super.drawTextFormat();						// Apply anti-aliasing to the text field.			var antiAliasType:String = getStyleValue("antiAliasType") as String;			if (antiAliasType == AntiAliasType.ADVANCED || antiAliasType == AntiAliasType.NORMAL)			{				textField.antiAliasType = antiAliasType;			}		}				override protected function drawLayout():void		{			super.drawLayout();						if (autoSize)			{				// Calculate new width of button based on text field size				var txtPad:Number = Number(getStyleValue("textPadding"));				var newWidth:Number = txtPad + textField.width + txtPad;				_width = newWidth;								// Re-layout the text field and background skin based on the new width				super.drawLayout();			}		}				override public function invalidate(property:String=InvalidationType.ALL, callLater:Boolean=true):void		{			if (parent && parent is LGBox)			{				if (property == InvalidationType.SIZE)				{					// If this component is nested inside a LGBox and it's size has changed then we need					// to invalidate the box it sits within.					(parent as LGBox).invalidate(InvalidationType.SIZE);				}			}			super.invalidate(property, callLater);		}				/*		public function get htmlLabel():String		{			return _label;		}						public function set htmlLabel(value:String):void		{			_label = value;			if (textField.htmlText != _label) {				textField.text = _label;				textField.htmlText = _label;				dispatchEvent(new ComponentEvent(ComponentEvent.LABEL_CHANGE));			}			invalidate(InvalidationType.SIZE);			invalidate(InvalidationType.STYLES);		}				override protected function draw():void {						if (isInvalid(InvalidationType.STYLES) || isInvalid(InvalidationType.SIZE)) {				drawEmphasized();			}			//---						//if (textField.text != _label) { 			//	label = _label;			//}						if (isInvalid(InvalidationType.STYLES,InvalidationType.STATE)) {				drawBackground();				drawIcon();				drawTextFormat();								invalidate(InvalidationType.SIZE,false);			}			if (isInvalid(InvalidationType.SIZE)) {				drawLayout();			}			if (isInvalid(InvalidationType.SIZE,InvalidationType.STYLES)) {				if (isFocused && focusManager.showFocusIndicator) { drawFocus(true); }			}			validate(); // because we're not calling super.draw						//---						if (emphasizedBorder != null) {				setChildIndex(emphasizedBorder, numChildren-1);			}					}		*/	}}